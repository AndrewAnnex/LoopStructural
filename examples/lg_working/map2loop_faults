#import the Forward Modelling Engine modules - FME
from LoopStructural.interpolators.piecewiselinear_interpolator import PiecewiseLinearInterpolator as PLI
from LoopStructural.interpolators.discrete_fold_interpolator import DiscreteFoldInterpolator as DFI
from LoopStructural.modelling.features.geological_feature import GeologicalFeatureInterpolator
from LoopStructural.modelling.features.structural_frame import StructuralFrameBuilder
from LoopStructural.modelling.fold.foldframe import FoldFrame
from LoopStructural.modelling.fold.fold import FoldEvent
from LoopStructural.modelling.fold.svariogram import SVariogram
from LoopStructural.supports.tet_mesh import TetMesh
from LoopStructural.visualisation.model_visualisation import LavaVuModelViewer
from LoopStructural.visualisation.rotation_angle_plotter import RotationAnglePlotter
from LoopStructural.supports.region_manager import RegionManager
# import other libraries
import geopandas
import pandas as pd
import numpy as np
from scipy.interpolate import Rbf
import matplotlib.pyplot as plt

import networkx as nx

minx=500057    #left hams
maxx=603028    #right
miny=7455348   #bottom
maxy=7567953   #top

maxz=1000
minz=-20000

boundary_points = np.zeros((2,3))
boundary_points[0,0] = minx
boundary_points[0,1] = miny
boundary_points[0,2] = minz
boundary_points[1,0] = maxx
boundary_points[1,1] = maxy
boundary_points[1,2] = maxz
mesh = TetMesh()

scale = np.max([np.max(maxx-minx),np.max(maxy-miny)])

def scale_pd(points,scale,boundary_points):
    points['X']-=boundary_points[0,0]
    points['Y']-=boundary_points[0,1]
    points['Z']-=boundary_points[0,2]


    points['X']/=scale
    points['Y']/=scale
    points['Z']/=scale
    return points

fault_ori = pd.read_csv('/home/lgrose/lachlan.grose@monash.edu/Loop/m2l_loopstruct/hams2_fault_orientations.csv')
fault_points = pd.read_csv('/home/lgrose/lachlan.grose@monash.edu/Loop/m2l_loopstruct/hams2_faults.csv')
scale_pd(fault_ori,scale,boundary_points)
scale_pd(fault_points,scale,boundary_points)

boundary_points[1,:] -= boundary_points[0,:]
boundary_points[0,:] = 0
boundary_points/=scale
buffer = 1000/scale
boundary_points[0,:]-=buffer
boundary_points[1,:]+=buffer
mesh.setup_mesh(boundary_points, n_tetra=400000,)


fault_ori['formation'] = fault_ori['formation'].map(lambda x: x.lstrip('Fault_'))
fault_points['formation'] = fault_points['formation'].map(lambda x: x.lstrip('Fault_'))

fault_tbl = pd.read_csv('/home/lgrose/lachlan.grose@monash.edu/Loop/m2l_loopstruct/fault-fault-relationships.csv')
fault_tbl = fault_tbl.set_index('fault_id')

from LoopStructural.modelling.features.geological_feature import GeologicalFeature
from LoopStructural.supports.scalar_field import ScalarField

regionmanager = RegionManager(mesh)
buffer = 5000 / scale
print(buffer)


def add_fault(n, abutregion=None, splayregion=None, splay=None):
    interpolators[n] = PLI(mesh)

    points = np.zeros((3, 2))
    for i in [-1, 0]:
        r = fault_points[fault_points['formation'] == n].iloc[i]
        points[:, i] = np.array([r['X'], r['Y'], r['Z']])
    bp = np.zeros((2, 3))
    bp[0, 0] = np.min(points[0, :])
    bp[1, 0] = np.max(points[0, :])
    bp[0, 1] = np.min(points[1, :])
    bp[1, 1] = np.max(points[1, :])
    bp[:, 2] = boundary_points[:, 2]
    bp[0, :] -= buffer
    bp[1, :] += buffer
    regionmanager.create_region_from_boundary_box(bp, n)
    points2[n] = points
    #     #print(mesh.properties)
    regions[n] = GeologicalFeature(n, ScalarField.from_node_values(mesh, 'REGION_' + n, mesh.regions[n].astype(float)))
    builders[n] = StructuralFrameBuilder(interpolators[n], name=n, mesh=mesh, region=n)
    vec1 = points[:, 0] - points[:, 1]
    vec1[2] = 0
    for i, r in fault_points.iterrows():
        if r['formation'] == n:
            builders[n].add_point([r['X'], r['Y'], r['Z']], 0, coord=0)
    for i, r in fault_ori.iterrows():
        #         print(r['X','Y','Z'])
        if r['formation'] == n:
            builders[n].add_strike_and_dip([r['X'], r['Y'], r['Z']], r['azimuth'] - 90,
                                           r['dip'], polarity=r['polarity'], coord=0)
    #     builders[n].add_planar_constraint([r['X'],r['Y'],r['Z']],vec1,coord=1)
    builders[n].interpolators[0].interpolation_weights['gpw'] = 1
    if splayregion is not None and splay is not None:
        for i in range(3):
            idc = np.arange(0, mesh.n_nodes)[~mesh.regions[splayregion]]
            val = faults[splay][i].support.get_node_values()[~mesh.regions[splayregion]]
            builders[n].interpolators[i].add_equality_constraints(idc, val)
    builders[n].interpolators[0].interpolation_weights['gpw'] = 1

    builders[n].interpolators[0].interpolation_weights['cgw'] = 0.1

    builders[n].interpolators[1].interpolation_weights['gpw'] = 1

    builders[n].interpolators[1].interpolation_weights['cpw'] = 1
    builders[n].interpolators[1].interpolation_weights['cgw'] = .1
    faults[n] = builders[n].build(solver='cg', gxxgy=0,maxiter=1000,tol=np.finfo('float').eps)
    try:
        v = []
        for i in [-1, 0]:
            r = fault_points[fault_points['formation'] == n].iloc[i]
            # print(np.array([[r['X'],r['Y'],r['Z']]]))
            v.append(faults[n][1].evaluate_value(np.array([[r['X'], r['Y'], r['Z']]])))
        # print(v)
        rng = np.abs(a[0] - a[1])
    #         mesh.regions[n] =  np.logical_and(
    #             faults[n][1].support.get_node_values()>v[0]-rng*.3,
    #             faults[n][1].support.get_node_values()<v[1]+rng*.3)
    #         for i in range(3):
    #             faults[n][i].region = n
    except:
        print(n)
    if abutregion is not None:
        for i in range(3):
            faults[n][i].region = n  # abutregion


faults = {}
interpolators = {}
builders = {}
regions = {}
points2 = {}

unique_faults = fault_points['formation'].drop_duplicates()

for f in unique_faults[:10]:
    add_fault(f)

viewer = LavaVuModelViewer(background='white')

for f in regions.keys():
#     try:
#     print(f)
#     try:
    colour=np.random.rand(3,)
#     viewer.add_isosurface(regions[f],
# #                        nslices=10,
#                        isovalue=0,
#                           colour=colour
#                          )
#     except:
#         pass
    viewer.add_isosurface(faults[f].features[0],
#                        nslices=10,
                       isovalue=0,
                          colour='black',
                        voxet={'bounding_box':boundary_points,'nsteps':(50,50,25)},
                         )
#     viewer.add_scalar_field(boundary_points,(38,55,30),
#                           f,
#                          paint_with=regions[f],
#                          cmap='prism')
#     viewer.add_data(faults[f][0])
    viewer.add_points(points2[f].T,f+'p',pointsize=10,colour=colour)
viewer.lv.rotate([-39.731422424316406, 25.943470001220703, 21.35618019104004])
viewer.interactive()